# Propuesta modernización aplicación Contabilidad

## Situación actual

| Aspecto | Descripción |
|---|---|
| **Tecnología** | Aplicación de escritorio desarrollada en **Visual Basic 6** con aproximadamente 250 formularios (`.frm`), componentes y dependencias. Se distribuye como instalador y requiere un ejecutable adicional para las actualizaciones. |
| **Módulos** | **Módulo 1 (Administrador):** gestiona empresas y datos transversales. **Módulo 2 (Cliente):** gestiona cuentas corrientes, activo fijo, libros legales e impuestos del artículo 14D. |
| **Base de datos** | Bases de datos locales en **Microsoft Access** o **SQL Server Express** instaladas **on‑premise**. |
| **Usuarios** | ~600 clientes, algunos utilizan versiones antiguas de Windows (XP, etc.), lo que limita la capacidad de actualizar componentes. |
| **Problemas** | Dependencia de VB6 (plataforma obsoleta), dificultades para instalar en sistemas modernos, mantenimiento costoso, código acoplado, dependencia de actualizador externo. |

### Riesgos estado actual

- **Soporte limitado y riesgos de seguridad:** VB6 tiene un alto riesgo por sus vulnerabilidades y costes de mantenimiento.
- **Escasa modularidad:** el código está repartido en muchos formularios y módulos con fuertes dependencias, lo que dificulta refactorizar o agregar nuevas funcionalidades.
- **Dependencia de sistemas operativos antiguos:** algunos clientes usan Windows XP u otras versiones no soportadas, limitando la adopción de nuevas tecnologías.

## Situación deseada

- **Aplicación moderna on premise (.NET 9 u .NET 8 LTS):** se busca utilizar .NET 9 autocontenido, lo que permite que el runtime y todas las dependencias se incluyan en el ejecutable y no requiera instalación de .NET. Sin embargo, .NET 9 es una versión *Standard Term Support (STS)* con soporte de 18 meses. Si se necesita mayor estabilidad, se puede evaluar .NET 8 LTS (soporte por tres años).  
- **Migración a una base de datos ligera sin servidor:** **SQLite** es una opción autocontenida, fiable y de cero configuración. Su base de datos se guarda en un único archivo y ocupa poco espacio. Para clientes que necesiten funciones avanzadas o replicación, se puede seguir usando SQL Server Express LocalDB.
- **Arquitectura de código basada en features y cloud-ready:** se organizará el código por funcionalidades, encapsulando comandos, consultas, lógica de negocio, acceso a datos y controladores en cada feature. Esto minimiza el acoplamiento y mejora la cohesión.
- **Interfaz modernizada:** la capa de presentación podría implementarse en **MAUI** para compatibilidad multiplataforma, **WPF**/WinForms autocontenida o **Blazor WebView** para un enfoque web local. Un backend **API REST** en ASP.NET Core permitirá desacoplar la lógica y facilitar una futura migración a la nube.
- **Actualizaciones automáticas y CI/CD:** la app se distribuirá mediante instaladores MSIX o ejecutables autocontenidos y contará con un servicio interno que compruebe nuevas versiones y se actualice de manera silenciosa. Se configurarán pipelines de CI/CD en GitHub Actions para compilar, probar y publicar cada release.
- **Pruebas unitarias e integración continua:** adoptar pruebas desde el inicio y utilizar herramientas de IA para generar documentación y casos de prueba.
- **Participación y motivación del equipo:** fomentar una cultura de **mejora continua** y aprendizaje para superar la resistencia al cambio. Mostrar beneficios del nuevo enfoque y oportunidad de utilizacion de nuevas tecnologías.

## Estrategia

1. **Análisis y planificación**
   - **Inventario del código**: evaluar los ~250 formularios VB6, componentes externos y dependencias. Clasificar módulos por criticidad y dificultad.
   - **Entrevistas con usuarios y equipo de soporte**: identificar funcionalidades críticas y flujos de trabajo reales. Involucrar a usuarios resistentes para obtener su perspectiva.
   - **Evaluación de tecnologías**: realizar pruebas de concepto con .NET 9/8 y SQLite para validar compatibilidad y rendimiento. Si se determina que el tamaño de las aplicaciones autocontenidas es problemático, considerar publicarlas como *framework-dependent* (instalador más ligero) o utilizar técnicas de *trim*.

2. **Diseño de la arquitectura deseada**
   - **Backend API**: implementar una API REST con ASP.NET Core organizada en vertical slices (por ejemplo, `Features/Empresas`, `Features/Activos`, etc.). Cada slice contendrá comandos, consultas, validaciones, servicios y controladores. 
   - **Capa de datos**: usar **Entity Framework Core** con SQLite para la persistencia. Los modelos se pueden generar a partir de la base actual, adaptando los tipos de datos.
   - **Capa de presentación**: elegir WPF/MAUI/Blazor WebView según los requisitos de experiencia de usuario y hardware. La UI consumirá la API REST local.
   - **Servicios de actualización**: integrar un módulo que verifique versiones en un servidor central y realice actualizaciones silenciosas. Para los clientes que no puedan tener conexión permanente, se debe ofrecer un instalador de parches. Candidato: **Squirrel**

3. **Refactorización y desacoplamiento**
   - **Estategia incremental**: comenzar con la creación de nuevas funcionalidades en la arquitectura moderna y rodear el sistema VB6 existente. Migrar gradualmente los módulos de VB6 a C# y retirar el código antiguo. Esto evita el enfoque *big bang* y reduce el riesgo.
   - **Servicios compartidos**: extraer utilidades y lógica común a bibliotecas independientes para evitar duplicación.
   - **Pruebas automatizadas**: al migrar cada módulo, crear pruebas unitarias que comparen resultados con la versión VB6 para asegurar equivalencia.

4. **Herramientas de IA y automatización**
   - **Análisis de código VB6**: emplear herramientas de Generative AI para mapear las dependencias, generar documentación y sugerir traducciones a C#. Esto puede reducir los tiempos de modernización en un 40 % y mejorar la comprensión del código.
   - **Generación de pruebas**: usar IA para crear casos de prueba y documentación. La automatización de pruebas y documentación reduce esfuerzo y riesgo de errores.
   - **Copilots y asistentes**: integrar herramientas como GitHub Copilot para la refactorización y adopción de patrones de diseño.

5. **Gestión del cambio y motivación de desarrolladores**
   - **Cultura de mejora continua**: fomentar la mentalidad de que el cambio es un proceso evolutivo y no una interrupción. Comunicar que la modernización ofrece oportunidades de aprendizaje y crecimiento profesional.
   - **Reconocimiento y participación**: reconocer las contribuciones de cada desarrollador y asignarles responsabilidad en decisiones de diseño. Escuchar a los más resistentes y demostrar beneficios con pruebas de concepto.

6. **Estrategias de migración y despliegue**
   - **Migración iterativa**: mover funcionalidades módulo por módulo, empezando por las menos críticas. Cada iteración incluirá análisis, desarrollo, pruebas y despliegue piloto.
   - **Paralelismo**: permitir que las versiones VB6 y .NET coexistan durante un periodo para validar resultados. Se puede usar un puente para que los datos se sincronicen.
   - **Pruebas de usuario y feedback**: liberar versiones beta a usuarios seleccionados para obtener retroalimentación temprana.
   - **Plan de despliegue final**: una vez que la mayoría de funcionalidades estén migradas, planificar la entrega general. Proporcionar soporte para incidencias.

## Estimaciones

El siguiente backlog está pensado para **un solo desarrollador** y utiliza estimaciones en días laborables. Se contemplan tres escenarios: Optimista (O), Normal (N) y Pesimista (P).  

| Épica / Historia de usuario | Resumen de tareas | O | N | P |
|---|---|---|---|---|
| **Épica 1: Diagnóstico y planificación** |||||
| *Como analista quiero inventariar el código VB6* para conocer formularios, componentes y dependencias y planificar la migración. | Ejecutar herramientas de análisis, catalogar formularios y dependencias, documentar riesgos. | 4 | 6 | 10 |
| *Como product owner quiero entrevistar usuarios (incluidos los resistentes) y equipo de soporte* para entender flujos reales y requisitos. | Planificar entrevistas, realizar reuniones, recoger feedback y expectativas. | 4 | 6 | 8 |
| *Como product owner quiero definir la visión de la situación deseada* para alinear al equipo y stakeholders. | Establecer objetivos, priorizar funcionalidades, crear mapa de ruta. | 2 | 3 | 5 |
| **Épica 2: Diseño y preparación** |||||
| *Como arquitecto quiero diseñar la arquitectura de vertical slices* para organizar la nueva aplicación de forma cohesiva. | Crear estructura de carpetas por feature, definir dependencias, documentar normas de codificación. | 3 | 5 | 8 |
| *Como DBA quiero diseñar el esquema SQLite* y las estrategias de migración de datos desde Access/SQL Express. | Definir modelo de datos, escribir scripts de migración, validar integridad. | 5 | 7 | 12 |
| *Como dev quiero configurar CI/CD con GitHub Actions* para compilar, ejecutar pruebas y publicar instaladores. | Crear workflows de build, test, análisis estático y empaquetado. | 3 | 5 | 7 |
| *Como dev quiero configurar herramientas de IA* para análisis de código y generación de pruebas. | Seleccionar herramientas, integrarlas en el repositorio, documentar su uso. | 2 | 3 | 5 |
| *Como product owner quiero definir estrategias de formación y motivación* para el equipo. | Diseñar plan de capacitación, coaching y comunidades de práctica; preparar sesiones de comunicación. | 3 | 5 | 7 |
| **Épica 3: Migración iterativa (por módulo)** |||||
| *Como dev quiero migrar el módulo Administrador* a C#/.NET. | Diseñar API y UI para gestiones de empresas; migrar lógica; crear pruebas; desplegar versión piloto. | 15 | 20 | 30 |
| *Como dev quiero migrar el módulo Cuentas Corrientes* a C#/.NET. | Implementar slice `CuentasCorrientes`, reescribir cálculos, pruebas, despliegue. | 15 | 20 | 30 |
| *Como dev quiero migrar el módulo Activo Fijo* a C#/.NET. | Migrar cálculos de depreciación, reportes; implementar slice correspondiente. | 12 | 16 | 25 |
| *Como dev quiero migrar el módulo Libros Legales e Impuestos* a C#/.NET. | Migrar generación de libros e impuestos artículo 14D; validar cálculos. | 15 | 20 | 30 |
| *Como dev quiero desacoplar la lógica de negocio de la UI* implementando API REST y servicios. | Crear comandos y consultas, separar reglas de dominio, exponer endpoints. | 8 | 12 | 18 |
| *Como dev quiero integrar el servicio de actualizaciones automáticas* en la nueva aplicación. | Diseñar mecanismo de comprobación, descarga e instalación de nuevas versiones. | 5 | 7 | 12 |
| *Como dev quiero empaquetar la aplicación en instaladores autocontenidos* o framework-dependent según el análisis de tamaño y soporte. | Configurar MSIX o ejecutables, firmar certificados y validar en clientes. | 3 | 5 | 8 |
| **Épica 4: Pruebas y estabilización** |||||
| *Como tester quiero ejecutar pruebas unitarias e integración* para asegurar la paridad con VB6. | Configurar proyectos de prueba, escribir casos y comparar resultados. | 5 | 7 | 10 |
| *Como usuario clave quiero validar la aplicación migrada* para garantizar que satisface las necesidades. | Planificar pruebas piloto, recopilar feedback, reportar fallos. | 4 | 6 | 8 |
| *Como dev quiero optimizar rendimiento y corregir errores* detectados durante las pruebas. | Analizar informes de rendimiento, refactorizar y ajustar consultas. | 3 | 5 | 8 |
| *Como product owner quiero preparar manuales y material de capacitación* para los usuarios finales. | Crear documentación, videos de entrenamiento, planes de adopción. | 4 | 6 | 8 |
| *Como product owner quiero planificar el despliegue final a los 600 clientes* de forma segura. | Definir ventanas de instalación, comunicación, contingencias y soporte. | 3 | 5 | 7 |
| **Épica 5: Soporte y mejora continua** |||||
| *Como dev quiero atender incidencias y liberar correcciones* después del lanzamiento. | Mantener un sistema de tickets, asignar prioridades, publicar parches. | 2 | 4 | 6 |
| *Como arquitecto quiero explorar la migración del backend a la nube* en el futuro. | Evaluar plataformas (Azure, AWS), analizar costos y prototipos. | 5 | 8 | 12 |
| *Como product owner quiero medir métricas de uso y satisfacción* para guiar mejoras. | Implementar telemetría, analizar feedback y ajustar backlog. | 3 | 5 | 7 |
| **Total** ||128|186|281|


## Consideraciones adicionales y riesgos

- **Tamaño y actualizaciones de aplicaciones autocontenidas:** las aplicaciones autocontenidas incluyen el runtime y todas las librerías, por lo que su tamaño y requisitos de almacenamiento son mayores. Además, actualizar la versión de .NET dentro de una app autocontenida requiere liberar una nueva versión de la aplicación. Se debe evaluar si un despliegue *framework‑dependent* (que requiere instalar .NET en el cliente) reduce el tamaño y simplifica actualizaciones.
- **Duración de soporte de .NET 9:** .NET 9 es una versión STS con soporte de 18 meses. Si se requiere un ciclo de vida más largo, se puede optar por .NET 8 LTS (soporte de tres años). 
- **Gestión de datos:** al migrar a SQLite se deben considerar las limitaciones (concurrencia, tamaño) y las implicancias de migrar datos desde Access/SQL Server. Hacer copias de seguridad y pruebas de integridad.
- **Resistencia al cambio:** involucrar a los desarrolladores desde el inicio y comunicar los beneficios técnicos y profesionales. Ofrecer formación y comunidades de práctica para reducir la resistencia.
- **Complejidad de componentes de terceros:** identificar controles o librerías VB6 sin soporte y evaluar alternativas modernas o desarrollar reemplazos.
- **Planificación incremental:** evitar un enfoque *big bang* y adoptar migración gradual para minimizar riesgos.

## Conclusión

Modernizar la aplicación contable implica pasar de un entorno VB6 obsoleto y difícil de mantener a una plataforma moderna basada en .NET y SQLite. La arquitectura de **Vertical Slice** permitirá organizar el código por funcionalidades con alta cohesión y bajo acoplamiento. El plan presenta un camino iterativo con historias de usuario y estimaciones que ayudan a gestionar el trabajo de un solo desarrollador y a mitigar riesgos.
